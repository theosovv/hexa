// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: scenes.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createScene = `-- name: CreateScene :one
INSERT INTO scenes (id, track_id, name, state_data, position)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, track_id, name, state_data, position, created_at
`

type CreateSceneParams struct {
	ID        uuid.UUID   `json:"id"`
	TrackID   pgtype.UUID `json:"track_id"`
	Name      string      `json:"name"`
	StateData []byte      `json:"state_data"`
	Position  pgtype.Int4 `json:"position"`
}

func (q *Queries) CreateScene(ctx context.Context, arg CreateSceneParams) (Scene, error) {
	row := q.db.QueryRow(ctx, createScene,
		arg.ID,
		arg.TrackID,
		arg.Name,
		arg.StateData,
		arg.Position,
	)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.TrackID,
		&i.Name,
		&i.StateData,
		&i.Position,
		&i.CreatedAt,
	)
	return i, err
}

const deleteScene = `-- name: DeleteScene :exec
DELETE FROM scenes
WHERE id = $1
`

func (q *Queries) DeleteScene(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteScene, id)
	return err
}

const getScene = `-- name: GetScene :one
SELECT id, track_id, name, state_data, position, created_at
FROM scenes
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetScene(ctx context.Context, id uuid.UUID) (Scene, error) {
	row := q.db.QueryRow(ctx, getScene, id)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.TrackID,
		&i.Name,
		&i.StateData,
		&i.Position,
		&i.CreatedAt,
	)
	return i, err
}

const listScenesByTrack = `-- name: ListScenesByTrack :many
SELECT id, track_id, name, state_data, position, created_at
FROM scenes
WHERE track_id = $1
ORDER BY position ASC, created_at ASC
`

func (q *Queries) ListScenesByTrack(ctx context.Context, trackID pgtype.UUID) ([]Scene, error) {
	rows, err := q.db.Query(ctx, listScenesByTrack, trackID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Scene
	for rows.Next() {
		var i Scene
		if err := rows.Scan(
			&i.ID,
			&i.TrackID,
			&i.Name,
			&i.StateData,
			&i.Position,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateScene = `-- name: UpdateScene :one
UPDATE scenes
SET name = $2,
    state_data = $3,
    position = $4
WHERE id = $1
RETURNING id, track_id, name, state_data, position, created_at
`

type UpdateSceneParams struct {
	ID        uuid.UUID   `json:"id"`
	Name      string      `json:"name"`
	StateData []byte      `json:"state_data"`
	Position  pgtype.Int4 `json:"position"`
}

func (q *Queries) UpdateScene(ctx context.Context, arg UpdateSceneParams) (Scene, error) {
	row := q.db.QueryRow(ctx, updateScene,
		arg.ID,
		arg.Name,
		arg.StateData,
		arg.Position,
	)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.TrackID,
		&i.Name,
		&i.StateData,
		&i.Position,
		&i.CreatedAt,
	)
	return i, err
}
